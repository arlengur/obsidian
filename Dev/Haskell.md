https://stepik.org/lesson/12399/step/4?unit=2829
https://github.com/gusenov/stepik-functional-programming-hs
https://www.youtube.com/watch?v=ykHPwmeu8c4&list=PLgkiApDiZ0KHacTxxunGYTLC_qG2fR-4S&index=71

Чистый функциональный язык программирования с ленивой семантикой и полиморфной статической типизацией

Нет циклов
Нет изменяемых переменных
Чувствителен к отступам (увеличение безопасно (говорит, что мы продолжаем определение с предыдущей строки, уменьшение может привести к проблемам). С нулевого отступа начинаются глобальные объявления

# Команды
- :t (тип объекта)
- :i (тип объекта и доп информация)
- :l (загрузка модуля)
- :set +s позволяет отслеживать использование памяти и затраты времени на вычисление выражения

Пример:
Создаем файл Hello.hs `main = putStrLn "Hello, world!"` и запустить `ghci Hello.hs` и там `main` получим `Hello, world!`
Выйти из ghci `ctrl+D`

Пример:
```haskell
module Test where

main :: IO ()
main = putStrLn "Hello world from module Test!"
```

# Функции

Определение функции
```haskell
sumSquares x y = x ^ 2 + y ^ 2
```

Если функция не принимает аргументов то это константа

вызов функции:  
```haskell
max 5 4
(max 5) 4
3 + (max 5) 4
```

logBase - функция вычисления логарифма по произвольному основанию 
`logBase 2 8` - вычисление логарифма по основанию 2 от 8

`lenVec3 x y z = sqrt(x ^ 2 + y ^ 2 + z ^ 2)` - функция вычисляет длину трехмерного вектора

`sign x = if x == 0 then 0 else (if x > 0 then 1 else (-1))` - возвращает 1, если передано положительное число, (-1), если отрицательное, и 0 в случае, когда передан 0

`mod` возвращает остаток от целочисленного деления первого своего аргумента на второй

`const :: a -> b -> a` принимает 2 аргумента и возвращает первый из них
# Частично примененная функция
```haskell
max5 x = max 5 x
-- or
max5` = max 5 -- когда не указываем всех аргументов это без точечный стиль
```

Префиксный стиль - это когда функция идет перед своими аргументами (`max 6 7`)

# Операторы
Операторы вызываются в инфиксном стиле (`6 + 7`)

Операторы и функции - это одно и тоже!

Чтобы использовать функцию в операторном стиле 
```haskell
6 `max` 7
```

Использование операторов в функциональном стиле `(+) 6 7`

Все операторы бинарные, кроме "-" он может быть унарным, поэтому его заключают в скобки `max (-5) 5`

Приоритет операторов

| Приоритет | Операторы              |
| --------- | ---------------------- |
| 8         | ^, logBase             |
| 7         | *, /, div, mod         |
| 6         | +, -                   |
| 4         | `==, /=, >, >=, <, <=` |

Оператор вычитания лево-ассоциативный
Ключевое слово `infix` задает ассоциативность

Нет встроенных операторов, но можно задать свой оператор
```haskell
infixl 6 *+*
a *+* b = a ^ 2 + b ^ 2

-- возвращает модуль разности переданных ему аргументов
infixl 6 |-|
x |-| y = abs (x-y)
```

Частичное применение оператора `(/) 2` эквивалентным к нему является сечение оператора `(2 /)` также можно связать правый аргумент в функциональном стиле `(/ 2)`. Круглые скобки обязательны в синтаксисе оператора сечения.

Определение бинарного оператора `f $ x = f x`, этот оператор с 0 приоритетом, что позволяет использовать его для избавления от избыточных скобок `sin $ pi / 2`. Также он имеет правую ассоциативность и имеет тип `(a -> b) -> a -> b` и применяет первый аргумент ко второму аргументу

`.` оператор композиции функций. Имеет приоритет 9 т правую ассоциативность

# Базовые типы

haskell - типизированный язык со строгой статической системой типов. 
Строгий - нет неявного приведения типов. 
Статический - проверка типов происходит во время компиляции

Тип константы
```haskell
x = 3 :: Int
:type x -- Int
:t 'c' -- Char
:t True -- Bool
:t 3 -- Num a => a - тип числового литерала 3 это произвольное значение а, которое присутствует с контекстом (Num a) а должно быть представителем класса типов Num
:t 3.5 -- Fractional a => a - к типу Fractional относятся Double, Float
```

Integer может содержать константы произвольной длины

## Иерархия типов
![[type_hierarhy_hs.png|center|350]]

Описание типа функции
```haskell
:t not -- Bool -> Bool
:t (&&) -- Bool -> (Bool -> Bool) - стрелка правоассоциативная, поэтому скобки можно опустить
```

Импорт модуля
```haskell
import Data.Char
test = isDigit `7`
```

https://hoogle.haskell.org/ справочная система haskell
# Кортеж
```haskell
(2, True) -- миксфиксный стиль
(,,) True 3 'v' -- префиксный стиль
fst (2, True) -- функция возвращает первый элемент
snd (2, True) -- функция возвращает второй элемент
() -- пустой кортеж
:t ('2', True) -- (Char, Bool)
```

Кортежи гетерогенные (разные типы)
# Список
Списки гомогенные (один тип) их длина нефиксирована
`[1, 2, 3]`

```haskell
[`h`, `i`] -- [Char]
"hi" -- [Char] or String

`H` : "ello" -- добавление в голову, приоритет 5
"hello" ++ " world" -- конкатенация списков, приоритет 5

:t [False, True] -- [Bool]
```

# Рекурсия
```haskell
fact n = if n == 0 then 1 else n * fact (n-1)
```

# Сопоставление с образцом
```haskell
fact` 0 = 1
fact` n = n * fact` (n-1)
```

# Ошибки
- error "Msg" прерывает выполнение программы и возвращает сообщение в диагностический поток
- undefined прерывает выполнение программы и возвращает стандартное сообщение об ошибке в диагностический поток

```haskell
fact` 0 = 1
fact` n = if n < 0 then error "arg must be >= 0" else n * fact` (n-1)
```

# Охранные выражения
```haskell
fact` 0 = 1
fact` n | n < 0 = error "arg must be >= 0"
        | n > 0 = n * fact` (n-1)
-- or

fact` :: Integer -> Integer
fact` n | n == 0 = 1
        | n > 0 = n * fact` (n-1)
        | otherwise = error "arg must be >= 0"
-- or

fact` n | n >= 0 = helper 1 n
        | otherwise = error "arg must be >= 0"

helper acc 0 = acc
helper acc n = helper (acc * n) (n-1)
```

Пример последовательность чисел Фибоначчи
0,1,1,2,3,5,8,13,21...
F0=0
F1=1
Fn=Fn-1+Fn-2
```haskell
fibonacci :: Integer -> Integer
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n | n > 0 = fibonacci (n - 1) + fibonacci (n - 2)
            | otherwise = fibonacci (n + 2) - fibonacci (n + 1)

-- линейная сложность по числу рекурсивных вызовов
fibonacci :: Integer -> Integer
fibonacci n = help 0 1 n 
        
help ac1 ac2 n | n == 0 = ac1
               | n == 1 = ac2
               | n > 0 = help ac2 (ac1 + ac2) (n - 1)
               | n < 0 = help (ac2 - ac1) ac1 (n + 1)
``` 
# Локальное связывание
## Выражение let-in
- локальное связывание переменной
```haskell
roots a b c =
 let d = sqrt (b^2 - 4*a*c) in
 ((-b-d)) / (2*a), (-b-d) / (2*a))

-- несколько связываний
roots a b c =
 let {d = sqrt (b^2 - 4*a*c); x1 = (-b-d)) / (2*a); x2 = (-b-d) / (2*a)} 
 in (x1, x2)

-- локальные связывания должны иметь одинаковый отступ
roots a b c =
 let 
  d = sqrt (b^2 - 4*a*c)
  x1 = (-b-d)) / aTwice
  x2 = (-b-d) / aTwice
  aTwice = 2*a
 in (x1, x2)
```

- локальное связывание определения функции
```haskell
fact` n 
 | n >= 0 = let
     helper acc 0 = acc
     helper acc n = helper (acc * n) (n-1)
    in helper 1 n
 | otherwise = error "arg must be >= 0"
```

- связывание образцов
```haskell
rootsDiff a b c = let
 (x1, x2) = roots a b c
 in x2 - x1
```

## Конструкция where 
```haskell
roots a b c = (x1, x2) where
  d = sqrt (b^2 - 4*a*c)
  x1 = (-b-d)) / aTwice
  x2 = (-b-d) / aTwice
  aTwice = 2*a
```

- не является выражением т.е. может использоваться только в определении функции в качестве тела функции. Сделано это для того чтобы ее можно было использовать в нескольких уравнениях с охранными выражениями
```haskell
fact` n | n >= 0 = helper 1 n
        | otherwise = error "arg must be >= 0"
	where
     helper acc 0 = acc
     helper acc n = helper (acc * n) (n-1)
```

# Полиморфизм
- параметрический (код функции одинаковый для всех типов на которых он вызывается)
- специальный (для каждого типа своя реализация)
	- функция вызывается на разных типах данных, но каждый тип данных обеспечивает реализацию соответствующего интерфейса (класс типов), чтобы функция могла его вызвать
	- Например полиморфный оператор сложения

Функция обладает полиморфным поведением, если она может быть вызвана на значениях разных типов 

Пример параметрического полиморфизма
```haskell
id x = x -- параметрически полиморфная функция
:t id -- t -> t - где t переменная произвольного типа

k x y = x -- аналог const
undefined -- населяет любой допустимый тип
error "msg" -- полиморфна по возвращаемому значению, тоже населяет любой допустимый тип
```

Ограничение степени полиморфизма функции
```haskell
mono :: Char -> Char
mono x = x

-- частичное ограничение полиморфизма
semiMono :: Char -> a -> Char -- полиморфная 2 аргументу и мономорфна по первому
semiMono x y = x
```

Для вывода типов Хаскель использует алгоритм Хиндли Милнера
Списки и кортежи параметрически полиморфны
# Функции высших порядков
функция, которая принимает в качестве аргумента другую функцию
```haskell
apply2 f x = f (f x)
apply2 (++ "AB") "CD" -- CDABAB

flip f y x = f x y
flip (/) 4 2 -- 0.5

flip const 5 True -- True
```

# Анонимные функции (лямбда)
```haskell
(\x -> 2 * x + 7) 10 -- 27

let f = \x -> 2 * x + 7

let lenVec = \x -> \y -> sqrt $ x^2 + y^2
-- or
let lenVec = \x y -> sqrt $ x^2 + y^2
lenVec 3 4 -- 5

import Data.Function
let p1 = ((1,2), (3,4))
let p1 = ((5,6), (7,8))
sumFstFst = (+) `on` helper
 where helper pp = fst $ fst pp
 -- or
 sumFstFst = (+) `on` (\pp -> fst $ fst pp)
```

В модуле `Data.Function` определена функция высшего порядка `on`. 
```haskell
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c 
on op f x y = f x `op` f y
```
Она принимает четыре аргумента: 
- бинарный оператор с однотипными аргументами (типа `b`), 
- функцию `f :: a -> b`, возвращающую значение типа `b`, 
- два значения типа `a`. 
Функция `on` применяет `f` дважды к двум значениям типа `a` и передает результат в бинарный оператор.
# Оператор композиции функций
```haskell
compose f g = \x -> f (g x) -- аналог .

sumFstFst = (+) `on` (fst . fst)

doIt = f . g . h -- цепочка последовательных применений функций
```

Функция одной переменной `doItYourself` выбирает наибольшее из переданного ей аргумента и числа 42, затем возводит результат выбора в куб и, наконец, вычисляет логарифм по основанию 2 от полученного числа
```haskell
doItYourself = f . g . h

f = logBase 2
g = (^3)
h = max 42
```
# Каррирование
`curry` преобразует некаррированную функцию в каррированную
`uncurry` преобразует каррированную функцию в некаррированную
```
cur f x y = f (x, y)
```

# Контексты и классы типов
```
:t 7
7 :: Num a => a -- 7 имеет полиморфный тип а, где для типа а должен быть выставлен интерфейс Num

:t (+)
(+) :: Num a => a -> a -> a

:t (>)
> :: Ord a => a -> a -> Bool -- принимает 2 аргумента одинакового типа Ord и возвращает Bool

:t (> 7)
(> 7) :: (Num a, Ord a) => a -> Bool
```

## Объявление класса типов
```haskell
class Eq a where
 (==), (/=) :: a -> a -> Bool -- сигнатуры функций должны начинаться с ненулевого отступа
 x \= y = not (x == y) -- реализация методов по умолчанию
 x == y = not (x \= y) -- циклическая реализация методов по умолчанию
```

## Объявление представителей класса типов
```haskell
instance Eq Bool where
 True  == True  = True
 False == False = True
 _     == _     = False

-- реализация представителя класса Eq для пары (a, b)(полиморфный тип) возможна при наличии контекста (ограничения) (Eq a, Eq b) то есть тип а и тип b должны быть представителями класса Eq
instance (Eq a, Eq b) => Eq (a, b) where
 p1 == p2 = fst p1 == fst p2 && snd p1 == snd p2
```

Символ `_` используется когда значение неважно

В haskell объявление типов данных и реализация интерфейса разнесены

Функциональные типы не могут сравниваться на предмет равенства

Пример класс типов Printable, предоставляющий метод toString — функцию одной переменной, которая преобразует значение типа, являющегося представителем Printable, в строковое представление. Сделайте типы данных Bool и () представителями этого класса типов
```haskell
class Printable a where
	toString :: a -> String

instance Printable Bool where
	toString True = "true"
	toString False = "false"

instance Printable () where 
	toString _ = "unit type"

instance (Printable a, Printable b) => Printable (a, b) where
 toString p1 = "(" ++ (toString $ fst p) ++ "," ++ (toString $ snd p) ++ ")"
```

Не все типы могут быть представителями класса Eq (например функциональные типы)
# Расширение класса
```haskell
-- класс типов Ord расширяет Eq и задает порядок
class (Eq a) => Ord a where
 (<), (<=), (>=), (>) :: a -> a -> Bool
 max, min :: a -> a -> a
 compare :: a -> a -> Ordering

-- множественное наследование интерфейсов
class (Eq a, Printable a) => MyClass a where
...
```
# Классы Show и Read
Сериализация и десериализация значений типа

# Классы Enum и Bounded
Enum - движение по типу перечисления
Bounded - для указания верхней и нижней границы
```haskell
class Enum a where
 succ, pred :: a -> a
 toEnum :: Int -> a
 fromEnum :: a -> Int

class Bounded a where
 minBound, maxBound :: a

```

Тип Integer бесконечный и у него нельзя найти границы
# Класс Num и его расширения

Num его представителями являются все числа
Integral - целочисленное деление (div целочисленное деление, mod остаток от деления, divMod - пара, toInteger - приводит любой тип Integral к Integer)
Fractional - деление чисел с плавающей точкой (/ - деление)
Floating - определяет стандартные математические функции
RealFrac - округление чисел с плавающей точкой до целых
RealFloat - описывает внутреннее представление числе с плавающей точкой
```haskell
class Num a where
 (+), (-). (*) :: a -> a -> a
 negate :: a -> a 
 abs :: a -> a 
 signum :: a -> a 
 toInteger :: Integer -> a

 x - y = x + negate y
 negate x = 0 - x

--LAW
abs x * signum x == x
```

# Модели вычислений
При вызове функции есть 2 стратегии: 
- ленивая (выполняем подстановку аргументов а потом их вычисление) по умолчанию
- энергичная (выполняем вычисление аргументов а потом подстановку)

Если параметры в правой части функции игнорируются, то ленивая стратегия выигрывает, если параметры используются несколько раз, преимущество имеет энергичная стратегия

Редакс - выражение которое может быть упрощено

В функциональных языках результат вычисления не зависит от выбранной стратегии (это выполняется до тех пор пока программа является завершающейся) (в императивных языках это свойство не выполняется из-за изменяемых переменных)

Строгая функция - при передаче расходящегося вычисления результатом имеет расходящееся значение

Нестрогая функция - при передаче расходящегося вычисления результатом имеет нерасходящееся значение

Нормальная форма - когда выражение дошло до окончательного результата и у него больше никаких вычислений произвести нельзя
```haskell
42
(3,4)
\x -> x + 2

--не НФ
"Real" ++ "world"
sin (pi/2)
(\x -> x + 2) 5
(3, 1+5)
```

Слабая головная/заголовочная нормальная форма
```haskell
\x -> x + 2*3
(3, 1+5)
(,) (4*5) -- (,) конструктор типа
(+) (7^2)
```

# Форсирование вычислений
seq - вычислительный примитив, такой оператор н6е может быть реализован в haskell. Форсирует вычисления до слабой заголовочной нормальной формы
```haskell
seq :: a -> b -> b
seq _|_ b = _|_ -- _|_ основание
seq a b = b

seq  1 2 -- 2
seq undefined 2 -- undefined
seq (undefined, undefined) 2 -- 2
seq (\x -> undefined) 2 -- 2
```
## Аппликация с вызовом по значению
Оператор применения с вызовом по значению помогает избавиться от отложенных вычислений
```haskell
($!) :: (a->b) -> a -> b
	f $! x = x `seq` f x -- х приводится к слабой заголовочной нормальной форме, потом f применяется к х

const 42 $! undefined -- undefined
```
# Модули
Начинается с большой буквы, имя модуля совпадает с именем файла

Модуль prelude импортируется неявно
```haskell
module Demo where

import Data.Char -- импорт всех публичных функций
import Data.Char (toUpper) -- импорт только функции toUpper
import Data.Char (toUpper, toLower) -- импорт нескольких функций
import Data.Char hiding (toLower) -- импорт всех функций, кроме toLower
import qualified Data.List --все имена из модуля используются с префиксом из этого модуля 
import qualified Data.Set as Set --псевдоним 
```

# Экспорт модулей
```haskell
module Test where

sumIt x y = x + y
const42 = const 42

module Demo where
import Test
f1 = const42 True
f2 - sumIt 3 4

module Test2 (sumIt) where -- экспорт только sumIt

sumIt x y = x + y
const42 = const 42
```

# Этапы компиляции
- Синтаксический разбор файла исходного кода и всем именам добавляются имена модулей (и иерархических модулей)
- проверка типов
- преобразование программы на haskell в программу на языке кое
- оптимизация
- кодогенерация
	- код на языке кое в код стг машины (машина осуществляющая графовую редукцию)
	- код стг машины преобразуется в язык с--
	- кодогенерация (код на языке платформы или лввм)

# Конструирование списков
```haskell
[]
3 : []
lst = 5 : 3 : []
[5,3] == 5 : 3 : []

const42 = (42 :)
const42 [1,2,3]
```

# Деконструкция списков
```haskell
head [1,2,3] -- частичная функция
tail [1,2,3] -- частичная функция
second xs = head (tail xs)
second = head . tail

-- сопоставление с образцом
fst ((,) x y) = x 
head ((:) x xs) = x -- (префиксный стиль)
second (_ : xs) = head xs
second (_ : x : _) = x
tail (x : xs) = xs -- инфиксный стиль
tail (_ : xs) = xs 
```

# Рекурсия над списками
```haskell
length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs

(++) : [a] -> [a] -> [a]
[] ++ ys = ys
(x:xs) ++ = x : xs ++ ys

null :: [a] -> Bool
null [] = True
null _ = False

last :: [a] -> a
last (x:[]) = x
last (_:xs) = last xs

init :: [a] -> [a]
init [] = error "ERR"
init [_] = []
init (x:xs) = x : init xs

reverse :: [a] -> [a]
reverse l = rev l [] where
 rev [] a = a
 rev (x:xs) a = rev xs (x:a)

zip :: [a] -> [b] -> [(a,b)]
zip [] _ = []
zip as [] = []
zip (a:as) (b:bs) = (a,b) : zip as bs

zip3 :: [a] -> [b] -> [c] [(a,b,c)]
zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
zip3 _ _ _ = []

unzip :: [(a,b)] -> ([a], [b])
unzip [] = ([], [])
unzip ((x,y):xys) =
 let (xs,ys) = unzip xys
 in (x:xs,y:ys)

take :: Int -> [a] -> [a]
take n _ | n <= 0 = []
take _ [] = []
take n (x:xs) = x : take (n-1) xs

drop :: Int -> [a] -> [a]
drop n xs | n <= 0 = xs
drop _ [] = []
drop n (_:xs) = drop (n-1) xs

splitAt :: Int -> [a] -> ([a], [a])
splitAt n xs = (take n xs, drop n xs)

xs !! n | n<0 = error "negative index"
[] !! _ = error "index too large"
(x:_) !! 0 = x
(_:xs) !! n = xs !! (n-1)
```

# Функции с аргументами предикатами
Унарный предикат - функция принимающая значение а возвращает булево значение
```haskell
filter :: (a -> Bool) -> [a] -> [a]
filter p [] = []
filter p (x:xs)
 | p x = x : filter p xs
 | otherwise = filter p xs

takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile p [] = []
takeWhile p (x:xs)
 | p x = x : takeWhile p xs
 | otherwise = []

dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile p [] = []
dropWhile p xs@(x:xs') --локальный псевдоним
 | p x = dropWhile p xs'
 | otherwise = xs

span :: (a -> Bool) -> [a] -> ([a],[a])
span p xs = (takeWhile p xs, dropWhile p xs)

break :: (a -> Bool) -> [a] -> ([a],[a])
break p = span (not . p)
```

# Функция map
```haskell
map :: (a -> b) -> [a] -> [a]
map _ [] = []
map f (x:xs) = f x : map f xs

concat :: [[a]] -> [a]
concat [] = []
concat (xs:xss) = xs ++ concat xss

concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f = concat . map f

and, or :: [Bool] -> Bool

and [] = True
and (x: xs) = x && and xs

or [] = False
or (x: xs) = x || or xs

all :: (a -> Bool) -> [a] -> Bool
all p = and . map p

any :: (a -> Bool) -> [a] -> Bool
any p = or . map p
```

Пример: Перевернуть каждое слово в строке
words разбивает строку на список строк по пробелу
```haskell
unwords . map reverse . words $ "Abc is not ABC"
```

```haskell
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith _ [] _ = []
zipWith _ _ [] = []
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
```

# Бесконечные списки
