https://microservices.io/
# Сервис это то у чего есть АПИ 
- Запросы и команды определяющие операции
- Публикация эвентов при изменении сервиса
- клиент отправляет команды и запросы и получает эвенты

Как делить приложение
- одно приложение на одну бизнес-функцию
- domain-driven-design (как доменные функции приложения отображаются на приложение)

# Service discovery
Когда запускаем несколько экземпляров сервиса то используем Service registry где в табличке храним адреса по которым может быть доступен наш сервис. Эта реализация лучше подобной реализации на уровне инфраструктуры так как в этом случае мы можем определять какие адреса кому отдавать и можно тестирование проводить. Хорошо подходит когда переписываем монолит на микросервисы и для монолита можно такой сервис прикрутить
- Плюсы
	- можно развернуть в любой инфраструктуре
- Минусы
	- Надо самому его поддерживать 
	- для всех языков приложения надо иметь реализации


Если реализуется платформой
- Плюсы
	- кибернетис поддерживает его работоспособность не надо об этом беспокоиться
- Минусы
	- Имеем только то что дает кибернетис и никуда от этого не денемся 

# Брокер
- Плюсы
	- loose coupling
	- message buffering
- Минусы
	- место где все может упасть
	- добавляет дополнительную сложность его поддержания

Если нет брокера
- Плюсы
	- малые задержки при отправке
	- нет лишней сложности поддержания
- Минусы
	- сервисы должны знать местонахождения друг друга
	- падает availability доступность так как теперь надо пересылать сообщения

Обработка повторных сообщений в случае брокера
- идемпотентность операций (одинаково обрабатывает при одних и тех же данных)
- transaction table записывать обработанные ид в таблицу
# Синхронное и асинхронное взаимодействие
- Синхронное
	- Плюсы
		- просто реализовать
		- не нужен промежуточный брокер
	- Минусы
		- снижает availability
		- клиенты должны знать куда отправлять запросы
- Асинхронное
	- Плюсы
		- неблокирующие, хорошо масштабируются
		- запросы отправляются не конкретным сервисам а промежуточное хранилище
	- Минусы
		- Сложно обрабатывать ошибки
		- непредсказуемое время обработки
# Patterns
## Transactional outbox
Наш сервис пишет в БД и табличку outbox из которой читает воркер и отправляет в брокер сообщений.

## API Composer
Когда все запросы идут через сервис который отправляет необходимые запросы в другие сервисы
- Плюсы
	- простой и интуитивный
- Минусы
	- дополнительная сложность
	- уменьшается availability доступность
	- уменьшает согласованность

## API Gateway
Когда в зависимости от клиента разный АПИ используем и там еще может быть общий слой который делает вызовы следующих микросервисов
## Command and Query Responsibility Segregation (CQRS)
Нужен когда у каждого сервиса своя БД, 
Разделяется на команды (изменение данных, CRUD БД) и запросы (получение данных, текстовая БД).
Например сервис который собирает данные с других реализует шаблон (издатель-подписчик) и когда у других сервисов происходит изменение они кидают событие о изменении данных и наш сервис их вычитывает
Плюсы: 
- денормализованная вью (собирающая данные с разных сервисов
- распределение ответственности (separation of concerns)
- помогает реализовать эвент сорсинг
Минусы
- сложно реализовывать (надо знать много о микросервисной архитектуре
- дубликат кода
- запаздывание при поддержке согласованности данных

## Database per Service
Одна бд на микросервис

## Event sourcing
Просто реализуем шаблон издатель-подписчик
Если событий слишком много надо делать снапшоты, тогда когда количество изменений достигает критической массы происходит обновление нашей сущности
Плюсы
- Event-driven-arch
- храним не сами объекты а события которые приводят к обновлению объектов
- надежная система аудирования событий (в последствии можно провести анализ) audit logging
- в любой момент можно получить актуальносе состояние сущностей
- пониженное сцепление между сущностями (loosely coupled)
Минусы
- сложно реализовывать (надо знать много о микросервисной архитектуре
- необходимо реализовать CQRS
- необходимо поддерживать согласованность данных

## Stability patterns
Отвечают за стабилизацию системы и чтобы она не вышла из строя
### Retry pattern
Восстанавливает разорванное соединение
Плохое решение при повторяющейся ошибке соединения (так как сервис который его использует в это время тоже не отвечает на запросы)

### Timeout pattern
Connection timeout - максимальное время ожидания для установки соединения
Socket timeout - максимальное время ожидания при обменен данными

### Circuit Breaker
Когда запросы фейлятся чтобы не перегрузить сервис используется механизм короткого замыкания, который ограничивает новые запросы если старые фейлятся. У него могут быть 3 состояния: open (есть проблема), halfopen (восстановление соединения), closed (все работает)

### Handshaking pattern
- Проверяем работоспособность сервиса health ckeck
- Получаем клиента например заголовком x-client и затем отправить ему reduce

### Bulkheads pattern
Изолирует ресурсы для какой-то группы пользователей
- resource per client (браузер или телефон)
- resource per application (каждое приложение в своем контейнере со своими ресурсами)
- resource per endpoint (сторонний сервис с которым общается наш сервис)

## Deployment
Push-based config
Конфигурация из инфраструктуры (докер файл или докер компоуз)
- Плюс
	- нужно только уметь читать из переменных окружения
Pull-based config
Сторонний сервис предоставляет конфигурацию (spring-cloud-conf)

## Observability
- Health check API (прометиус, кубер)
	- live & ready
- Logging (эластик (хранит) лог стеш (собирает логи) экибана (показывает))
- Tracing
- Metrics (прометиус)
- Exceptions (эластик лог стеш экибана)
- Audit